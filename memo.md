#server clientの構造
サーバーは常にリッスンしていて、クライアントから接続があったら通信を別のスレッドの立ち上げてそちらでするようにしている。サーバーは送られてきたデーターをそのまま接続している他のクライアントにsendするだけ。そのため多人数も実装出来ている。（しかし多人数だと極端に遅くなる）

#clientについて
クライアントはrecから読み込んで、サーバーのsendする処理とサーバーからデータを受け取ってplayに書き出すという処理があるがそれぞれを別のスレッドで処理をしているので、どちらかの応答が遅くなっても一応は動くはずである。
またubuntuでは動かないようだが、recからの読み出しとsendは別のスレッドで行ってrecの読み込みとsendが終わると送るデータのポインタを入れ替えるだけで切り替えを実現する処理も実装した。
こうすることでsendが遅くなってもrecにたまらないので積もり遅延が小さいはずである。
言葉では分かりにくいが、具体的なフローは以下のとおりである。

状態1 rec は buffer1に書き込み。
      sendは buffer2を送る。
sendが終わると、
状態2 recはbuffer2に書き込み。
      sendはbuffer1を送る。
といった感じである。しかしいまの所Nが大きすぎてrecの方が時間がかかっている気がするのであんまり意味ないのかも。


#マルチスレッドによるFFTの計測

##並列化
fft_rの再帰呼び出しの所をマルチスレッドにしてみた。しかしすべてスレッドにすると、createするコストのほうが高いため遅くなる。なので最初の何回かはマルチスレッドにして、そこからは普通に呼び出すことにした。
最適な階層を見つけるために計測してみた。

## 計測方法

```
    const auto startTime = std::chrono::system_clock::now();
    fft(X, Y, FN);
    const auto endTime = std::chrono::system_clock::now();
    const auto timeSpan = endTime - startTime;
    std::cout << "処理時間:" << std::chrono::duration_cast<std::chrono::milliseconds>(timeSpan).count() << "[ms]" << std::endl;
    exit(1);
```

## 結果

| Therad_num(log) | time[ms]                |                |
| :-------------- | :---------------------- | :-----------   |
| 1               | 16,16,15,15,16          |                |
| 2               | 8,9,8,8,10,8,8          |                |
| 3               | 10,5,9,5,8              |                |
| 4               | 8,6,56,7,7,7,           | バラつきが多少 |
| 5               | 7,7,8,6,15,6            |                |
| 6               |                         |                |
| 7               | 10,30,17,16,11          |                |
| 8               | 30,19,20,11,13,16,13    |                |
| 10              | 68,75,66,66,68          |                |

3ぐらいがいいのかな？


#窓関数
FFTは入力された有限区間の周期波形をフーリエ変換しているので、最初と最後が繋がっている必要がある。Nが小さいいと不連続となっている箇所が増えるので雑く聞こえる。なので窓関数をかけてかけて最初と最後を０に近づけるとよい。実際、窓関数がないとN=8192以上ないとまともに聞こえなかったのに、窓関数をつけるとN=1024でも聞こえた。
しかし、窓関数を書けたあとの波形は実際の波形とは違うのでFFT後の周波数は変更することが出来ない。
これでは送るデータが増えてしまうので意味が無い。なにかうまい方法があるのだろうか？
